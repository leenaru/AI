>>> Llama3를 gguf 파일로 로컬에 다운받아설치하고 ollama를 이용해서 langgraph연동해서 질문에 대한 의도를 파악하는 코드를 작성해줘


아래는 Llama3 모델의 GGUF 파일을 로컬에 설치하고, Ollama를 통해 LangGraph와 연동하여 사용자의 질문에 대한 의도를 파악하는 예제 코드 및 과정입니다.

### 단계별 설치 및 구현 방법

---

## 1. GGUF 파일을 이용한 로컬 Llama3 설치 (Ollama 사용)

Ollama는 자동으로 모델을 관리하지만, GGUF 파일을 직접 설치하고 싶다면 다음 절차를 따릅니다.

### GGUF 파일 다운로드

* [Llama3 GGUF 모델](https://huggingface.co/TheBloke/Llama-3-8B-GGUF) 에서 원하는 모델 (예: `llama-3-8b-instruct.Q4_K_M.gguf`)을 다운로드하여 로컬에 저장합니다.

예시 경로:

```
~/models/llama-3-8b-instruct.Q4_K_M.gguf
```

---

## 2. Ollama에 GGUF 모델 등록 및 실행

먼저 Ollama를 설치합니다.

```bash
curl -fsSL https://ollama.com/install.sh | sh
```

다음과 같이 모델을 로컬에서 등록합니다.

### 모델 등록 명령어

```bash
ollama create llama3-local -f Modelfile
```

### Modelfile 내용 (`Modelfile`)

```
FROM ./models/llama-3-8b-instruct.Q4_K_M.gguf
TEMPLATE """<|begin_of_text|><|start_header_id|>user<|end_header_id|>
{{ .Prompt }}<|eot_id|><|start_header_id|>assistant<|end_header_id|>
"""
```

모델 실행 테스트:

```bash
ollama run llama3-local
```

모델이 정상적으로 로딩되었는지 확인하세요.

---

## 3. Python 환경 설정

필요한 라이브러리 설치 (LangGraph, Ollama Python 클라이언트):

```bash
pip install langgraph ollama
```

---

## 4. LangGraph와 Ollama를 이용한 Intent Detection 코드 구현

다음은 LangGraph를 사용하여 Ollama의 Llama3 모델을 호출하고, 사용자의 질문으로부터 의도를 추출하는 예제입니다.

### 예제 코드 (`llama3_langgraph_intent.py`)

```python
from langgraph.graph import END, StateGraph
from langgraph.prebuilt import ToolNode
from typing import TypedDict, List
import ollama
import json

# 상태를 관리할 클래스 정의
class AgentState(TypedDict):
    prompt: str
    intent: str

# Ollama 클라이언트를 통해 Llama3 호출하는 함수
def llama3_intent_classifier(prompt: str) -> str:
    system_prompt = (
        "다음 사용자의 질문을 분석하여 의도를 '여행예약', '호텔예약', '식당예약', '항공예약', '기타' 중 하나로 분류하세요.\n"
        "결과는 JSON 형태로 {\"intent\": \"분류결과\"} 로만 답변하세요."
    )

    response = ollama.chat(
        model="llama3-local",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": prompt},
        ]
    )

    try:
        intent_json = json.loads(response['message']['content'])
        return intent_json.get('intent', '기타')
    except json.JSONDecodeError:
        return '기타'

# LangGraph 노드 정의
def classify_intent(state: AgentState) -> AgentState:
    prompt = state['prompt']
    intent = llama3_intent_classifier(prompt)
    return {"prompt": prompt, "intent": intent}

# 그래프 생성
workflow = StateGraph(AgentState)

# 의도 분류 노드 추가
workflow.add_node("intent_classifier", classify_intent)
workflow.set_entry_point("intent_classifier")
workflow.add_edge("intent_classifier", END)

app = workflow.compile()

# 실행 예시
if __name__ == "__main__":
    user_input = input("질문을 입력하세요: ")
    result = app.invoke({"prompt": user_input})
    print(f"질문: {result['prompt']}\n의도: {result['intent']}")
```

---

## 5. 실행 방법

코드를 실행하여 동작 확인:

```bash
python llama3_langgraph_intent.py
```

### 실행 예시

```bash
질문을 입력하세요: 내일 오전 10시 인천에서 도쿄 가는 비행기 예약해줘
질문: 내일 오전 10시 인천에서 도쿄 가는 비행기 예약해줘
의도: 항공예약
```

---

## 요약 및 정리

* **GGUF 파일 다운로드** 후 로컬 Ollama 모델로 등록
* **Ollama를 통해 로컬에서 Llama3** 사용
* **LangGraph** 를 사용하여 **Ollama의 Llama3 모델 호출**
* 간단한 **intent classifier** 구현 및 사용

이 과정으로 Llama3를 로컬에 배포하여 LangGraph와 Ollama를 통해 간편하게 의도를 분류할 수 있는 기능을 구축할 수 있습니다.

---

>>> 위의 예제에서 의도는 사전에 정의된 것으로만 분류할 수 있는거야? 분류외의 의도 파악하는 방법에는 어떤것이 있을까

위 예제는 미리 정해놓은 몇 가지 카테고리(예: '여행예약', '호텔예약', '식당예약', '항공예약', '기타') 내에서만 의도를 분류하는 방식입니다. 이 접근법을 \*\*"폐쇄형 분류 (Closed-set Classification)"\*\*라고 합니다.

하지만 현실적으로 사용자의 질문은 사전에 정의되지 않은 다양한 의도가 있을 수 있으며, 이런 경우 더 유연하고 개방적인 의도 분류가 필요합니다.

---

## 💡 분류 외의 다양한 의도를 파악하는 방법

의도를 보다 유연하게 파악하는 방법으로는 크게 다음과 같은 접근이 있습니다.

### 1️⃣ **개방형 분류 (Open-set Classification)**

* **개념**

  * 정의된 클래스 외에도, 모델이 "기타(Unknown)"를 넘어 보다 구체적인 의도를 유연하게 제시하는 방법.
  * LLM의 생성능력을 활용하여 자유로운 형태의 텍스트로 의도를 서술합니다.

* **예시**

  * 사용자 질문: `"이번에 여행갈 때 아이랑 가볼만한 체험할 수 있는 농장이 있을까?"`
  * 폐쇄형 분류: `"기타"`
  * 개방형 분류: `"아이와 함께할 수 있는 농장 체험 여행지 추천"`

* **구현법**

  * LLM이 자유롭게 의도를 기술하도록 system\_prompt를 바꿔줍니다.

```python
system_prompt = (
    "다음 사용자의 질문의 핵심 의도를 20자 내외의 짧은 문장으로 요약해 주세요."
)
```

* **장점**

  * 사전 정의하지 않은 수많은 의도에 대해 유연한 대응 가능
  * 사용자 질의의 디테일을 잘 반영할 수 있음.

* **단점**

  * 생성된 의도를 후속 시스템에 매핑하려면 추가 처리가 필요할 수 있음.

---

### 2️⃣ **하이브리드 방식 (Hybrid Intent Detection)**

* **개념**

  * 폐쇄형 분류를 기본으로 사용하되, `"기타"` 범주일 경우 개방형으로 추가로 처리하는 방법.
  * 즉, 미리 정의된 의도일 경우엔 정해진 레이블을 사용하고, 아닌 경우엔 의도를 더 구체적으로 설명하도록 모델이 생성하는 방식입니다.

* **예시**

```python
def llama3_intent_classifier_hybrid(prompt: str) -> dict:
    system_prompt = (
        "다음 질문의 의도를 '여행예약', '호텔예약', '식당예약', '항공예약', '기타' 중 하나로 우선 분류하고, "
        "'기타'인 경우에는 의도를 20자 내외로 간략하게 요약해주세요.\n"
        "결과는 JSON으로 {\"intent\": \"분류결과\", \"detail\": \"기타 의도인 경우의 요약(없으면 빈문자열)\"} 로 답변하세요."
    )

    response = ollama.chat(
        model="llama3-local",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": prompt},
        ]
    )

    try:
        intent_json = json.loads(response['message']['content'])
        return intent_json
    except json.JSONDecodeError:
        return {'intent': '기타', 'detail': ''}
```

* **장점**

  * 사전에 정의된 의도는 명확하게 관리되면서, 새로운 유형의 질의도 빠르게 식별 가능
  * 현실적인 서비스 운영에 가장 적합한 방식

* **단점**

  * 약간의 추가 처리 오버헤드

---

### 3️⃣ **임베딩 기반 의도 유사도 분류 (Semantic Similarity)**

* **개념**

  * 임베딩을 활용해 사용자 입력과 사전에 준비한 샘플 문장과의 유사도를 계산하여, 가장 가까운 의도를 동적으로 찾아내는 방법.

* **흐름**

  * 사용자의 질문 → 임베딩 벡터 변환 → 사전에 정의된 의도별 대표 질문 문장과 유사도 비교 → 가장 높은 유사도를 가진 의도 할당 또는 일정 threshold 이하일 경우 "새로운 의도"로 간주.

* **장점**

  * 특정 분류 카테고리가 많아도 쉽게 확장 가능
  * 새로운 질문 유형 등장 시 유사도를 기준으로 자동 처리 가능

* **단점**

  * 의도 간 경계가 모호할 수 있음
  * 임베딩 모델 및 threshold 관리 필요

* **주요 라이브러리**

  * OpenAI Embeddings API, Sentence-BERT, Cohere Embeddings 등.

```python
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sentence_transformers import SentenceTransformer

model = SentenceTransformer('all-MiniLM-L6-v2')

intents = {
    "호텔예약": ["호텔 잡아줘", "호텔 예약해줘"],
    "식당예약": ["맛집 예약", "식당 자리 예약"],
    # 기타 의도 추가 가능
}

intent_embeddings = {intent: np.mean(model.encode(examples), axis=0) for intent, examples in intents.items()}

def classify_semantic_intent(user_input):
    user_embedding = model.encode([user_input])[0]
    scores = {intent: cosine_similarity([user_embedding], [emb])[0][0] for intent, emb in intent_embeddings.items()}
    best_intent, best_score = max(scores.items(), key=lambda x: x[1])
    
    threshold = 0.7
    if best_score < threshold:
        return "기타"
    return best_intent
```

---

## 🚩 방법별 추천 용도 및 비교

| 방법    | 장점           | 단점                      | 추천              |
| ----- | ------------ | ----------------------- | --------------- |
| 폐쇄형   | 빠르고 정확       | 제한적인 범위                 | 의도가 명확히 제한된 서비스 |
| 개방형   | 유연한 대응 가능    | 분류 관리가 어려움              | 자유롭고 다양한 질문처리   |
| 하이브리드 | 효율과 유연성의 균형  | 추가 처리 필요                | 현실적 운영 서비스      |
| 임베딩기반 | 확장성, 유지보수 편리 | 모호한 경계, threshold 조정 필요 | 카테고리가 많을 경우     |

---

## 🎯 **현실적으로 추천하는 방법**

* 초기 운영단계에서는 **하이브리드 방식**이 가장 효율적입니다.

  * 주요 카테고리는 정확히 관리하면서, 예측하지 못한 질문도 자연스럽게 대응 가능

* 장기적으로는 **임베딩 기반 분류**가 확장성이 좋으며, 추가적인 intent 관리가 쉬워 추천합니다.

---

이러한 방법 중 서비스의 목표와 상황에 따라 가장 적합한 방식을 선택하여 적용하면 보다 유연하고 효과적으로 의도를 파악할 수 있습니다.

---

>>> 의도에 따른 동작을 따로 정의해둘껀데, 이게 내용이 꽤 많고, 절차가 필요한 부분도 있고, 단계 저장이 필요할 수 있어. 이 많고 복잡한 내용들을 어떻게 관리하는게 좋을까


사용자의 질문에 따라 **의도를 분류한 후**, 각 의도에 대응되는 **복잡한 동작, 절차, 상태 관리**를 잘 처리하려면 아래와 같은 구조적 설계가 필요합니다:

---

## ✅ 목표 요약

* 의도(intent)에 따라 각기 다른 **동작 시나리오(task flow)** 실행
* 시나리오는 \*\*복잡한 절차와 단계(step)\*\*로 구성됨
* 사용자의 응답에 따라 **상태 저장 및 복원**이 필요함
* 다국어, 온디바이스/서버 분산 처리까지 고려됨

---

## 💡 추천 구조

### 🔷 1. **LangGraph 기반 FSM (상태머신) 아키텍처**

LangGraph는 복잡한 흐름과 상태 저장, 분기 처리를 자연스럽게 지원합니다. 아래처럼 구성할 수 있습니다:

#### \[1단계] 의도 분류 노드

* 사용자의 질문을 분석하여 `intent`를 결정
* 예: `항공예약`, `호텔예약`, `기타`

#### \[2단계] 의도에 따른 서브그래프 진입

* `router` 노드를 통해 intent별로 분기
* 각 intent는 독립적인 상태기계로 동작

#### \[3단계] 절차별 단계 노드 구성

* 예: `출발지 입력 → 도착지 입력 → 날짜 선택 → 항공편 제안`

#### \[4단계] 상태 저장 및 복원

* 각 단계는 AgentState에 저장됨
* LangGraph는 이 구조를 기반으로 다중턴 대화 지원

---

### 🔶 2. **의도별 Task Flow 정의 방법**

의도에 따른 동작을 **코드와 데이터 분리**해서 관리하는 것이 좋습니다:

```python
# JSON 또는 YAML로 정의
{
  "항공예약": {
    "steps": [
      {"name": "출발지", "prompt": "출발지를 알려주세요."},
      {"name": "도착지", "prompt": "도착지를 입력해주세요."},
      {"name": "출발일", "prompt": "출발 날짜를 알려주세요."},
      {"name": "승객 수", "prompt": "탑승 인원 수를 알려주세요."}
    ]
  },
  "호텔예약": {
    "steps": [
      {"name": "지역", "prompt": "숙박 지역을 입력해주세요."},
      {"name": "체크인", "prompt": "체크인 날짜를 알려주세요."},
      {"name": "체크아웃", "prompt": "체크아웃 날짜를 알려주세요."}
    ]
  }
}
```

이 데이터를 기반으로 LangGraph 노드를 **동적으로 생성**할 수 있습니다.

---

### 🔷 3. **상태 저장 및 다중턴 처리 예시**

```python
class AgentState(TypedDict):
    prompt: str
    intent: str
    step_index: int
    slots: dict
```

* `intent`: 현재 진행 중인 시나리오
* `step_index`: 현재 단계
* `slots`: 사용자 응답을 저장하는 필드

→ LangGraph는 각 단계에서 `step_index += 1` 하며 다음 질문으로 자연스럽게 넘어감

---

### 🔷 4. **예시 흐름 구조**

```
[사용자입력]
    ↓
[intent_classifier]
    ↓
[router]
 ├─ 항공예약 서브그래프 (출발지 → 도착지 → 날짜 → 항공편 제안)
 └─ 호텔예약 서브그래프 (지역 → 체크인 → 체크아웃)
```

각 노드는 사용자 입력을 받고 상태를 업데이트하며 다음 단계로 이동합니다.

---

## 📦 기술 스택 구성 제안

| 요소        | 기술                                  |
| --------- | ----------------------------------- |
| 의도 분류     | Ollama + LLM                        |
| 상태머신      | LangGraph                           |
| 시나리오 정의   | JSON, YAML (플러그인 가능하게)              |
| 상태 저장     | LangGraph의 상태 딕셔너리 또는 Redis 등 외부 저장 |
| 멀티턴 대화 유지 | 클라이언트에서 UUID 기반 세션 저장 or 서버 세션 관리   |
| 온디바이스 처리  | MobileBERT / TinyLLaMA 등            |
| 서버 연산     | Ollama 또는 OpenAI / Cohere 등         |

---

## 🧠 요약

* **LangGraph**를 중심으로 의도별 FSM을 구성
* 각 의도는 **JSON 또는 YAML**로 정의된 절차에 따라 처리
* **상태는 지속적으로 저장**, 다중턴에서 이어짐
* **하이브리드 처리** (온디바이스는 intent까지, 서버는 복잡한 절차 처리)
* 이 방식은 확장성, 유지보수성, 사용자 경험 모두 고려한 구조입니다.

---

원하신다면 아래처럼 샘플 구현 코드를 실제로 작성해드릴 수도 있습니다:

1. `항공예약` 시나리오의 LangGraph 정의
2. 시나리오 JSON 로딩 및 자동 그래프 생성 코드
3. 상태 저장과 중단/복원 예시

필요하시면 어떤 의도부터 먼저 구현할지 알려주세요 😊

---

>>> 자동차 운전에 대한 내용을 예시로 들어서 해줘. 시동 거는것 부터 운전 및 주차까지. 그리고 운전중에 발생하는 예외 상황 혹은 위기상황 등에 대한 대처등 최대한 많은 부분을 고려해서 작성해줘


좋습니다! 자동차 운전이라는 주제를 기반으로 **LangGraph를 활용한 절차형 AI Agent 시나리오 예제**를 아래에 정리해드릴게요. 이 예제는:

1. 시동 → 주행 → 주차까지의 기본 운전 플로우
2. 운전 중 발생 가능한 예외 상황 및 위기 대응
3. 상태 기반 다중턴 대화 흐름 (LangGraph 구조)
4. 각 단계를 동적으로 생성하기 위한 JSON 기반 시나리오 구성

---

## 🚘 자동차 운전 시나리오 플로우 (상세 절차)

### 💡 주요 Intent

* `시동걸기`
* `운전 시작하기`
* `운전 중 예외 상황 처리`
* `주차하기`

---

## 🔧 1. 시나리오 정의 (JSON 기반 예시)

```json
{
  "운전시나리오": {
    "steps": [
      { "name": "시동", "prompt": "자동차에 타셨나요? 시동을 걸어주세요. 시동이 걸렸으면 '시동 완료'라고 말씀해주세요." },
      { "name": "안전벨트", "prompt": "안전벨트를 착용하셨나요?" },
      { "name": "기어변경", "prompt": "기어를 'P'에서 'D'로 바꾸세요. 완료되면 알려주세요." },
      { "name": "주행시작", "prompt": "이제 출발하실 수 있어요. 천천히 출발하세요." },
      { "name": "교차로진입", "prompt": "교차로가 보이면 좌우를 살핀 후 진입하세요." },
      { "name": "차선변경", "prompt": "차선을 변경해야 하나요? 방향지시등을 켰는지 확인하세요." },
      { "name": "주차단계", "prompt": "도착하셨나요? 주차를 시작해 주세요. 완료되면 알려주세요." },
      { "name": "시동끄기", "prompt": "기어를 'P'로 옮기고, 시동을 끄세요. '운전 완료'라고 입력해주세요." }
    ],
    "exceptions": [
      {
        "name": "엔진경고등",
        "trigger": ["엔진 경고등", "체크 엔진"],
        "response": "엔진 경고등이 켜졌다면 차량을 정차하고 정비소에 연락하세요."
      },
      {
        "name": "타이어 펑크",
        "trigger": ["타이어", "펑크", "바람 빠짐"],
        "response": "비상등을 켜고 안전한 곳에 정차한 후, 스페어 타이어로 교체하거나 보험사에 연락하세요."
      },
      {
        "name": "브레이크 고장",
        "trigger": ["브레이크", "멈추지 않음"],
        "response": "브레이크가 작동하지 않으면 기어를 낮추고 사이드 브레이크를 천천히 작동시켜 차량을 멈추세요. 즉시 정비가 필요합니다."
      }
    ]
  }
}
```

---

## 🧠 2. LangGraph 기반 실행 흐름 (구성도)

```plaintext
[User Input]
     ↓
[intent_classifier]
     ↓
[router]
 ├─ 시동걸기 시나리오 → 시동 단계 진행
 ├─ 운전 시작 → 각 주행 단계 진행
 ├─ 위기상황 인식 → 예외 핸들링 단계로 분기
 └─ 주차 시나리오 → 종료 절차
```

---

## 🛠️ 3. LangGraph 예제 코드 (Python + Ollama)

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict, List
import json
import ollama

# 상태 클래스 정의
class AgentState(TypedDict):
    step_index: int
    intent: str
    slots: dict
    prompt: str

# 운전 시나리오 불러오기
with open('driving_scenario.json', 'r', encoding='utf-8') as f:
    scenario_data = json.load(f)['운전시나리오']

# 예외 처리 규칙
exception_rules = scenario_data['exceptions']

def detect_exception(user_input: str) -> str:
    for rule in exception_rules:
        for trig in rule['trigger']:
            if trig in user_input:
                return rule['response']
    return ""

# 다음 단계로 진행
def next_step(state: AgentState) -> AgentState:
    step_idx = state.get("step_index", 0)
    steps = scenario_data["steps"]

    if step_idx >= len(steps):
        return {**state, "prompt": "운전 시나리오가 모두 완료되었습니다.", "step_index": step_idx}

    next_prompt = steps[step_idx]["prompt"]
    return {
        **state,
        "prompt": next_prompt,
        "step_index": step_idx + 1
    }

# 예외 탐지 및 분기 처리
def handle_input(state: AgentState) -> AgentState:
    user_response = state["slots"].get("user_input", "")
    emergency = detect_exception(user_response)
    
    if emergency:
        return {**state, "prompt": f"[위기 상황 감지] {emergency}"}
    return next_step(state)

# 그래프 정의
graph = StateGraph(AgentState)
graph.add_node("step_executor", handle_input)
graph.set_entry_point("step_executor")
graph.add_edge("step_executor", END)

app = graph.compile()

# 실행 예시
if __name__ == "__main__":
    state = AgentState(intent="운전시나리오", step_index=0, slots={}, prompt="")
    while True:
        state = app.invoke(state)
        print(state['prompt'])

        if "완료되었습니다" in state["prompt"]:
            break

        user_input = input("→ ")
        state["slots"]["user_input"] = user_input
```

---

## 📌 결과 예시

```
자동차에 타셨나요? 시동을 걸어주세요. 시동이 걸렸으면 '시동 완료'라고 말씀해주세요.
→ 시동 완료
안전벨트를 착용하셨나요?
→ 네
기어를 'P'에서 'D'로 바꾸세요. 완료되면 알려주세요.
→ 완료
...
→ 엔진 경고등이 켜졌어요
[위기 상황 감지] 엔진 경고등이 켜졌다면 차량을 정차하고 정비소에 연락하세요.
```

---

## 📦 확장 아이디어

| 확장 요소           | 설명                         |
| --------------- | -------------------------- |
| 📍 지도 기반 처리     | GPS 연동하여 운전 경로 안내          |
| 📊 예외 통계 관리     | 위기 상황 대응 통계 자동 수집          |
| 🧠 사용자 맞춤형 응답   | 운전자 레벨(초보/숙련자)에 따라 프롬프트 변경 |
| 📁 시나리오 저장/불러오기 | 특정 시나리오 상태 저장 후 이어서 진행     |

---

필요하시면 이 예제를 기반으로:

* YAML 기반 시나리오 자동 변환
* 다국어 지원 추가
* FastAPI + Ollama 서버화

등도 구현 가능합니다. 어느 부분부터 확장하고 싶으신가요?

---

>>> 이거 모두 해줘
>>> - YAML 기반 시나리오 자동 변환
>>> -  다국어 지원 추가
>>> - FastAPI + Ollama 서버화

좋습니다! 요청하신 전체 구성은 아래와 같은 세 가지 파트를 포함합니다:

---

## ✅ 전체 구성 요약

| 기능                  | 구현 설명                                          |
| ------------------- | ---------------------------------------------- |
| 1️⃣ YAML 기반 시나리오 변환 | `.yaml` 파일로 절차/예외 시나리오 정의 후 Python에서 자동 로딩     |
| 2️⃣ 다국어 지원          | 사용자 언어 설정에 따라 프롬프트 출력 변경 (예: 한국어, 영어)          |
| 3️⃣ FastAPI 서버화     | Ollama와 LangGraph를 백엔드 서버 형태로 실행하여 REST API 제공 |

---

## 1️⃣ YAML 기반 시나리오 구조 예시 (`driving_scenario.yaml`)

```yaml
languages:
  ko:
    steps:
      - name: 시동
        prompt: "자동차에 타셨나요? 시동을 걸어주세요. 시동이 걸렸으면 '시동 완료'라고 말씀해주세요."
      - name: 안전벨트
        prompt: "안전벨트를 착용하셨나요?"
      - name: 기어변경
        prompt: "기어를 'P'에서 'D'로 바꾸세요. 완료되면 알려주세요."
      - name: 주행시작
        prompt: "이제 출발하실 수 있어요. 천천히 출발하세요."
      - name: 교차로진입
        prompt: "교차로가 보이면 좌우를 살핀 후 진입하세요."
      - name: 차선변경
        prompt: "차선을 변경해야 하나요? 방향지시등을 켰는지 확인하세요."
      - name: 주차단계
        prompt: "도착하셨나요? 주차를 시작해 주세요. 완료되면 알려주세요."
      - name: 시동끄기
        prompt: "기어를 'P'로 옮기고, 시동을 끄세요. '운전 완료'라고 입력해주세요."

    exceptions:
      - name: 엔진경고등
        trigger: ["엔진 경고등", "체크 엔진"]
        response: "엔진 경고등이 켜졌다면 차량을 정차하고 정비소에 연락하세요."
      - name: 타이어 펑크
        trigger: ["타이어", "펑크", "바람 빠짐"]
        response: "비상등을 켜고 안전한 곳에 정차한 후, 스페어 타이어로 교체하거나 보험사에 연락하세요."

  en:
    steps:
      - name: Start Engine
        prompt: "Are you in the car? Please start the engine. Say 'engine started' when done."
      - name: Seatbelt
        prompt: "Have you fastened your seatbelt?"
      - name: Gear Shift
        prompt: "Change gear from 'P' to 'D'. Let me know when done."
      - name: Start Driving
        prompt: "You can start driving now. Drive slowly."
      - name: Enter Intersection
        prompt: "Check left and right before entering the intersection."
      - name: Lane Change
        prompt: "Do you need to change lanes? Make sure the indicator is on."
      - name: Parking
        prompt: "Have you arrived? Start parking. Let me know when done."
      - name: Turn Off Engine
        prompt: "Shift to 'P' and turn off the engine. Type 'drive complete' to finish."

    exceptions:
      - name: Engine Warning
        trigger: ["engine warning", "check engine"]
        response: "Stop the vehicle and contact a repair shop if the engine warning light is on."
      - name: Tire Puncture
        trigger: ["flat tire", "puncture", "air leak"]
        response: "Turn on hazard lights, stop safely, and replace the tire or call assistance."
```

---

## 2️⃣ Python 코드: YAML 로딩 + 다국어 LangGraph + 예외처리

```python
import yaml
from langgraph.graph import StateGraph, END
from typing import TypedDict
import os

# 상태 정의
class AgentState(TypedDict):
    step_index: int
    intent: str
    language: str
    slots: dict
    prompt: str

# YAML 시나리오 로딩
def load_scenario(lang='ko'):
    with open("driving_scenario.yaml", "r", encoding="utf-8") as f:
        raw = yaml.safe_load(f)
    return raw[lang]

# 예외 탐지
def detect_exception(user_input: str, exception_rules: list) -> str:
    for rule in exception_rules:
        for keyword in rule['trigger']:
            if keyword.lower() in user_input.lower():
                return rule['response']
    return ""

# LangGraph 실행 노드
def step_executor(state: AgentState) -> AgentState:
    lang = state['language']
    scenario = load_scenario(lang)
    step_idx = state.get("step_index", 0)
    user_input = state["slots"].get("user_input", "")

    emergency = detect_exception(user_input, scenario['exceptions'])
    if emergency:
        return {**state, "prompt": f"[⚠ 위기상황] {emergency}"}

    if step_idx >= len(scenario['steps']):
        return {**state, "prompt": "[✅ 운전 완료]", "step_index": step_idx}

    prompt = scenario['steps'][step_idx]['prompt']
    return {**state, "prompt": prompt, "step_index": step_idx + 1}

# LangGraph 설정
graph = StateGraph(AgentState)
graph.add_node("step_executor", step_executor)
graph.set_entry_point("step_executor")
graph.add_edge("step_executor", END)
app = graph.compile()
```

---

## 3️⃣ FastAPI + Ollama 통합 서버

### ✅ 서버 코드 (`main.py`)

```python
from fastapi import FastAPI, Request
from pydantic import BaseModel
from langgraph_runner import app as langgraph_app
import uvicorn

app = FastAPI()

class UserRequest(BaseModel):
    session_id: str
    user_input: str
    language: str = "ko"  # default to Korean

# 세션 상태 저장 (임시 메모리)
SESSIONS = {}

@app.post("/drive")
def handle_drive(req: UserRequest):
    session_id = req.session_id
    user_input = req.user_input
    language = req.language

    # 초기 상태 설정
    if session_id not in SESSIONS:
        SESSIONS[session_id] = {
            "intent": "운전시나리오",
            "step_index": 0,
            "slots": {},
            "prompt": "",
            "language": language
        }

    state = SESSIONS[session_id]
    state["slots"]["user_input"] = user_input

    # LangGraph 호출
    result = langgraph_app.invoke(state)
    SESSIONS[session_id] = result  # 상태 저장
    return {"prompt": result["prompt"], "step": result["step_index"]}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
```

---

## ✅ 테스트 방법

```bash
# 서버 실행
python main.py
```

```bash
# API 요청 예시 (curl)
curl -X POST http://localhost:8000/drive \
     -H "Content-Type: application/json" \
     -d '{"session_id": "abc123", "user_input": "시동 완료", "language": "ko"}'
```

---

## 🧩 요약: 전체 구성 흐름

```plaintext
[YAML 시나리오 정의]
        ↓
[LangGraph FSM 구성]
        ↓
[FastAPI 서버화 → /drive API 제공]
        ↓
[사용자 입력에 따라 단계적 응답 생성 + 위기상황 대응]
```

---

이제 YAML 기반 시나리오 → 다국어 LangGraph FSM → FastAPI 서버까지 모두 통합한 구조가 완성되었습니다.

다음 단계로는 다음도 추가 가능합니다:

* 🌐 클라이언트 앱 연결 (React Native, Flutter 등)
* 💾 Redis 세션 저장
* 📖 사용자별 로그 기록 및 분석

원하시면 전체 코드를 GitHub repo 형식으로 정리하거나, Docker로 패키징해드릴 수 있습니다.
이후 어떤 부분부터 도와드릴까요?

---

>>> android 와 iOS 앱으로 연결할꺼야
>>> 그리고 음성모드를 지원해서 입력은 테스트 뿐만 아니라, 음성으로도 입력받게 할꺼야.
>>> 음성모드는 음성으로 입력받고 음성으로 답변을 출력

좋습니다! 아래는 요청하신 전체 시스템을 GitHub Repository 형식으로 정리한 구조입니다. 이 구조는 다음을 모두 포함합니다:

---

## 📁 GitHub Repo 구조 (`driving-agent-ai`)

```
driving-agent-ai/
│
├── README.md                          👈 프로젝트 설명 및 사용법
├── requirements.txt                  👈 Python 패키지 목록
├── Modelfile                         👈 Ollama 모델 정의
├── driving_scenario.yaml            👈 YAML 기반 다국어 운전 시나리오
│
├── app/
│   ├── main.py                      👈 FastAPI 서버 진입점
│   ├── langgraph_runner.py         👈 LangGraph FSM + YAML 로더
│   └── utils.py                    👈 예외처리 등 공용 함수
│
├── mobile/
│   ├── android/                    👈 (추후 연결) Android 클라이언트
│   └── ios/                        👈 (추후 연결) iOS 클라이언트
│
├── voice/
│   ├── stt_client.py               👈 음성 → 텍스트 (STT) 처리
│   ├── tts_client.py               👈 텍스트 → 음성 (TTS) 처리
│   └── config.py                   👈 음성 API 키 관리
```

---

## 🔧 핵심 파일 요약

### ✅ `driving_scenario.yaml`

다국어 운전 시나리오 및 예외 대응 정의

### ✅ `langgraph_runner.py`

LangGraph FSM 구성 + YAML 로딩 + 예외처리

### ✅ `main.py` (FastAPI API 서버)

* `/drive`: 입력받은 메시지를 기반으로 LangGraph 실행
* 세션 기반 다중턴 처리

### ✅ `stt_client.py` & `tts_client.py`

* STT: Google Cloud Speech-to-Text 또는 Whisper API 사용 가능
* TTS: Google TTS, Naver CLOVA, ElevenLabs 등 연동 가능
* 모바일 클라이언트에서 음성 모드일 경우, 이 파일들과 통신

---

## 📱 모바일 연동 방향

> Android와 iOS 모두 **REST API 호출 + TTS/STT 모듈 통합** 방식으로 구성

### 🔌 통신 흐름 (음성 모드)

```plaintext
(사용자 음성 입력)
  ↓ (STT)
음성 텍스트 변환 (STT)
  ↓
/drive API 호출 (POST)
  ↓
LangGraph 응답 프롬프트 수신
  ↓
텍스트를 음성으로 변환 (TTS)
  ↓
앱에서 음성 출력
```

* STT & TTS는 서버 또는 로컬 연동 가능
* 클라이언트에서 `음성모드` 여부를 요청 body에 포함시켜도 됨

---

## 📄 예시 `README.md`

````markdown
# 🚘 Driving Agent AI (LangGraph + Ollama + Voice + App)

이 프로젝트는 자동차 운전 시나리오를 따라 단계별 안내 및 위기 상황 대응이 가능한 AI Agent입니다.  
LangGraph + Ollama 기반으로 구축되었으며, Android/iOS 앱 및 음성 모드(STT/TTS)를 지원합니다.

---

## 🧩 기능

- 시동 → 운전 → 주차까지 단계적 안내
- 타이어 펑크, 브레이크 고장 등의 위기 대응
- YAML 기반 시나리오 정의
- 다국어 지원 (한국어, 영어)
- FastAPI 서버화
- Android/iOS 앱 연동
- 음성 입력(STT), 음성 출력(TTS)

---

## 🏃 실행 방법

```bash
# Python 의존성 설치
pip install -r requirements.txt

# 서버 실행
python app/main.py
````

API 호출 예시:

```bash
curl -X POST http://localhost:8000/drive \
     -H "Content-Type: application/json" \
     -d '{"session_id": "user1", "user_input": "시동 완료", "language": "ko"}'
```

---

## 📱 모바일 연동

모바일 앱은 REST API를 통해 다음을 수행합니다:

1. 음성으로 질문 → STT → 텍스트
2. 텍스트로 API 호출 → LangGraph 응답
3. 응답을 TTS로 변환 → 음성 출력

---

## 📁 디렉토리 구조

* `app/` - 서버 코드 (LangGraph + FastAPI)
* `voice/` - STT/TTS 클라이언트 모듈
* `mobile/` - Android/iOS 앱 샘플 연결 지점
* `driving_scenario.yaml` - 시나리오 정의

```

---

## 🧭 다음 단계 제안

1. `GitHub repo` 형태로 실제 파일 압축하여 전달 가능 (원할 경우 zip 생성)
2. 모바일 클라이언트 예제 코드 추가 가능 (SwiftUI, Jetpack Compose)
3. TTS/STT 설정을 위한 예시 API (Google Cloud, Naver CLOVA 등) 추가 가능
4. Dockerfile로 전체 패키징 가능

---

👉 원하시는 방식으로 zip 파일을 생성해드릴까요?  
또는 GitHub에 올릴 수 있는 `.zip` 형태로 코드 묶어서 드릴 수도 있습니다.  
그리고 Android/iOS 앱 예제 중 어떤 플랫폼부터 원하시나요?
```

---

>>> 그런데 다국어 지원이 모바일에서 지원하는 모든 언어를 지원하고 싶어. 근데 위 방법으로는 각 국가별로 시나리오를 정리해야하는데, 이거를 좀 더 스마트하게 하는 방법없어?


훌륭한 질문이에요. 말씀하신 대로 **언어별로 YAML에 시나리오를 일일이 정의**하는 것은:

* 국가 수가 많아질수록 **유지보수 비용 폭발**
* 동기화 누락, 번역 오류 발생 가능성 증가
* 개발자/기획자 입장에서 **확장성 매우 낮음**

---

## ✅ 목표

> "하나의 시나리오 구조를 기반으로, **모든 언어에 자동 번역된 프롬프트**를 실시간 생성"

---

## 💡 해결 방법: **동적 번역 기반 시나리오 생성**

### 핵심 아이디어

* YAML 시나리오 파일은 \*\*기본 언어(예: 영어)\*\*만 작성
* 사용자가 요청한 언어로 LangGraph 실행 시, 프롬프트를 **실시간 번역**
* 번역은 **LLM** 또는 \*\*API(Google/Naver/DeepL 등)\*\*를 통해 수행

---

## 📦 구현 방식

### 🔹 1. 기본 시나리오 YAML 구조 (1개 언어만 유지)

```yaml
scenario:
  steps:
    - name: Start Engine
      prompt: "Are you in the car? Please start the engine. Say 'engine started' when done."
    - name: Gear Shift
      prompt: "Change gear from 'P' to 'D'. Let me know when done."
  exceptions:
    - name: Engine Warning
      trigger: ["engine warning", "check engine"]
      response: "If the engine warning light is on, please stop and call a repair shop."
```

---

### 🔹 2. 다국어 번역 함수 (실시간 변환)

```python
from typing import List
import ollama

def translate_text(text: str, target_lang: str) -> str:
    prompt = f"Translate the following into {target_lang}:\n\n{text}"
    response = ollama.chat(
        model="llama3-local",  # or use openai, etc.
        messages=[{"role": "user", "content": prompt}]
    )
    return response['message']['content']
```

---

### 🔹 3. 시나리오 전체 번역 캐싱 처리

```python
def translate_scenario(base_scenario: dict, target_lang: str) -> dict:
    translated = {"steps": [], "exceptions": []}

    for step in base_scenario["steps"]:
        translated_prompt = translate_text(step["prompt"], target_lang)
        translated["steps"].append({"name": step["name"], "prompt": translated_prompt})

    for ex in base_scenario["exceptions"]:
        translated_resp = translate_text(ex["response"], target_lang)
        translated["exceptions"].append({
            "name": ex["name"],
            "trigger": ex["trigger"],
            "response": translated_resp
        })

    return translated
```

---

## 🧠 이 방식의 장점

| 항목     | 기존 방식 (언어별 YAML) | 동적 번역 방식          |
| ------ | ---------------- | ----------------- |
| 유지보수   | 언어 추가 시 파일 증가    | YAML 1개로 해결       |
| 번역 품질  | 수동 오류 가능성 있음     | LLM 자동 번역         |
| 코드 확장성 | 낮음               | 매우 높음             |
| 속도     | 빠름               | 약간 느리나 캐싱으로 해결 가능 |

---

## 💡 성능 최적화 팁

1. **LangGraph 실행 전에 번역 캐싱**

   * 사용자 언어 요청이 처음일 때만 번역 실행
   * 이후 Redis / 메모리 / 파일로 캐싱

2. **긴 프롬프트는 chunking 번역**

   * 한 번에 너무 많은 텍스트를 번역 요청하지 않도록 나눠서 처리

3. **오프라인 기기용 번역**

   * 미리 번역된 json 파일을 준비해놓고 사용하는 방식으로 fall-back

---

## ✨ 추가 확장

| 기능                     | 설명                                     |
| ---------------------- | -------------------------------------- |
| 🌐 LangChain Router 통합 | 사용 언어 감지 후 자동 분기 처리                    |
| 🎙️ 음성 언어 자동 감지        | 사용자 음성으로 언어 자동 설정                      |
| 📁 다국어 시나리오 export     | 특정 언어 요청 시 YAML 자동 생성 후 저장 (예: 번역 관리용) |

---

## 📌 요약

| 문제                 | 해결책                    |
| ------------------ | ---------------------- |
| 언어별 YAML 파일 너무 많아짐 | 👉 하나의 영어 YAML만 유지     |
| 다국어 번역 관리 어려움      | 👉 실시간 번역 (LLM or API) |
| 번역 비용 걱정           | 👉 캐싱 활용으로 1회만 번역      |

---

원하시면 이 동적 다국어 번역 기능을 포함한 코드를 `langgraph_runner.py`에 통합해드릴 수 있어요.
또는 실시간 + 캐시 구조로 바로 적용 가능한 구조로 zip 다시 만들어드릴 수도 있어요.

어떻게 도와드릴까요? 😊

---

>>> 좋아 시나리오에 따른 다양한 번역은 되는데, 이제 국가에 따라 시나리오가 다를 수 있자나. 예를들어 운전에 대한 규제등 국가마다 다르단말야. 이런것들은 어떻게 처리해야하지?

아주 좋은 질문입니다. 말씀하신 부분은 \*\*“언어”의 문제를 넘어서 “국가/지역별 시나리오의 차이”\*\*라는 중요한 문제로, 단순 번역으로는 해결할 수 없는 구조적 차이를 다루어야 합니다.

---

## ✅ 문제 정의

| 구분              | 예시                                                        |
| --------------- | --------------------------------------------------------- |
| **언어 차이**       | 영어 ↔ 한국어 번역                                               |
| **국가별 시나리오 차이** | 한국은 유턴 금지 구간이 많고, 일본은 좌측통행, 미국은 우회전 자유 등 **규칙/절차 자체가 다름** |

---

## 🎯 목표:

> **“국가(또는 지역)”별로 시나리오 로직 자체를 다르게 구성하되, 중복을 최소화하고 유지보수성을 높이는 구조 만들기**

---

## 💡 해결 전략: "시나리오 상속 + 번역 분리 + 규칙 확장"

### 🔷 1. 시나리오를 \*\*"지역별 분기" + "언어별 번역"\*\*으로 분리

* "지역" = **로직 분기 기준**
* "언어" = **UI 텍스트 출력용**

---

## ✅ 구조 제안

### 📁 시나리오 디렉토리 구조

```
scenarios/
├── global.yaml                 # 전 세계 공통 시나리오 (기본 구조)
├── korea.yaml                 # 한국 특화 시나리오 (상속/덮어쓰기 가능)
├── usa.yaml                   # 미국 특화 시나리오
├── japan.yaml                 # 일본 특화 시나리오
└── ...
```

### 🌐 언어 번역 JSON

```
translations/
├── ko.json
├── en.json
├── ja.json
└── ...
```

---

## 🛠️ 2. 국가별 시나리오 구조 예시 (`korea.yaml`)

```yaml
extends: global
scenario:
  steps:
    - name: 유턴규칙
      prompt_key: uturn_rule_korea
    - name: 고속도로진입
      prompt_key: highway_entry_korea
  overrides:
    - name: 차선변경
      prompt_key: korean_lane_change
```

## 🌐 번역 JSON (`ko.json`)

```json
{
  "uturn_rule_korea": "한국에서는 대부분의 도로에서 유턴이 제한됩니다. 유턴 가능 구간을 확인하세요.",
  "highway_entry_korea": "고속도로 진입 전, 하이패스 여부를 확인하세요.",
  "korean_lane_change": "차선 변경 시 반드시 방향지시등을 3초 이상 켜세요."
}
```

---

## 🧠 실행 흐름

```plaintext
[사용자 요청]
   ↓
[국가 코드 → 시나리오 선택]
   ↓
[언어 코드 → prompt_key 를 번역]
   ↓
[LangGraph 실행]
```

### 예시

* 사용자: `country="KR", language="en"`
  → `korea.yaml` + `en.json` 조합으로 실행

* 사용자: `country="JP", language="ja"`
  → `japan.yaml` + `ja.json`

---

## 💡 장점 요약

| 항목               | 설명                     |
| ---------------- | ---------------------- |
| 시나리오/로직과 텍스트 분리  | 유지보수 용이                |
| 국가별 규제, 절차 반영 가능 | 일본은 좌측통행, 미국은 우회전 자유 등 |
| 언어는 번역 키로 처리     | 모든 언어 자동 지원            |
| 공통 시나리오 상속       | 반복 제거, 오버라이드 가능        |

---

## 🧱 기술 구현 요약

* YAML 파서가 `extends: global` 을 만나면 부모 시나리오 불러와 병합
* `prompt_key`로 텍스트를 관리하고 언어에 따라 번역 파일에서 매핑
* LangGraph의 prompt는 `translate(prompt_key, lang)`을 통해 적용

---

## 📦 추가 옵션

* 지역별 TTS/STT 엔진 자동 선택
* 지도 API 연동 시 현지 도로 교통 법규 자동 반영
* fallback: 국가가 없으면 `global.yaml` 사용

---

## ✅ 결론

| 해결 방법                       | 핵심                  |
| --------------------------- | ------------------- |
| 로직은 “국가(country)” 기준으로 분리   | → YAML 시나리오 분기      |
| 텍스트는 “언어(language)” 기준으로 번역 | → 다국어 JSON          |
| 상속 구조로 공통 유지                | → `extends: global` |

---

## 🛠️ 도와드릴 수 있는 작업

1. `global.yaml`, `korea.yaml`, `usa.yaml` 예시 작성
2. `ko.json`, `en.json` 번역 키/값 구성
3. 병합 로더 Python 코드 작성
4. zip 리팩토링 및 구조 반영

진행해드릴까요? 어느 국가부터 시작할까요? 🇰🇷 🇺🇸 🇯🇵 🇩🇪 🇫🇷 🇹🇭 🇧🇷 🇪🇸 …

---

>>> 상속과 덮어쓰기에 대한 예제를 좀 더 자세하게 보여줘. 국가외에도 특정 경우에 시나리오에 대한 차이가 있는 부분은 어떻게 처리해?

훌륭합니다.
이제 이 시스템을 **더 유연하게 확장**하기 위해서:

* **상속/덮어쓰기 구조를 명확히 이해하고**,
* **국가 외 조건들 (예: 초보 운전자, 전기차, 고속도로 주행 등)** 도 시나리오에 반영할 수 있는 **구조적 확장성**이 필요합니다.

---

## ✅ 1. 기본 시나리오 상속/덮어쓰기 예제

### 📁 예시 디렉토리 구조

```
scenarios/
├── global.yaml
├── korea.yaml         👈 한국 특화 시나리오 (상속 + 일부 단계 덮어쓰기)
├── beginner.yaml      👈 초보 운전자 시나리오 (추가 단계 삽입)
```

---

### 📄 `global.yaml` – 모든 시나리오의 기본 베이스

```yaml
scenario:
  steps:
    - name: start_engine
      prompt_key: start_engine
    - name: seatbelt
      prompt_key: seatbelt
    - name: gear_shift
      prompt_key: gear_shift
    - name: drive
      prompt_key: start_driving
    - name: parking
      prompt_key: parking
  exceptions:
    - name: engine_warning
      trigger: ["check engine", "engine light"]
      response_key: engine_warning
```

---

### 📄 `korea.yaml` – 한국 도로규칙 반영 예제 (덮어쓰기 + 추가)

```yaml
extends: global
scenario:
  overrides:
    - name: gear_shift
      prompt_key: gear_shift_korea  # 'P'에서 'D' 전환 전 사이드 브레이크 해제 강조
  insert_after:
    - name: seatbelt
      new_step:
        name: hpass_check
        prompt_key: korea_hpass
```

### 📄 `ko.json` 번역

```json
{
  "start_engine": "시동을 걸어주세요.",
  "seatbelt": "안전벨트를 착용하셨나요?",
  "gear_shift": "기어를 P에서 D로 바꿔주세요.",
  "gear_shift_korea": "한국에서는 사이드 브레이크를 먼저 해제한 후, P에서 D로 바꿔주세요.",
  "korea_hpass": "하이패스 단말기가 장착되었는지 확인해주세요.",
  "start_driving": "출발하세요.",
  "parking": "도착하셨나요? 주차를 진행하세요.",
  "engine_warning": "엔진 경고등이 켜졌습니다. 정비소에 문의하세요."
}
```

---

## 🧠 병합 결과 (자동 생성된 결과 구조)

```yaml
scenario:
  steps:
    - name: start_engine
    - name: seatbelt
    - name: hpass_check              # 추가됨
    - name: gear_shift              # 덮어쓰기
    - name: drive
    - name: parking
```

---

## ✅ 2. “국가 외 조건”에 따른 시나리오 분기 방법

국가 외에도 다음과 같은 조건으로 시나리오를 **상황에 맞게 조합**해야 할 수 있습니다:

| 조건 유형  | 예시              |
| ------ | --------------- |
| 운전자 상태 | 초보자, 고령자, 숙련자   |
| 차량 종류  | 전기차, 수동차, 자율주행차 |
| 도로 환경  | 고속도로, 산길, 도심    |
| 날씨 상황  | 눈, 비, 안개 등      |
| 탑승자    | 어린이, 반려동물 동승    |

---

## 🔧 해결 전략: **멀티 계층 조건 기반 시나리오 조합**

### 방법 1: 다중 `extends` 지원

```yaml
extends:
  - global
  - beginner
  - korea
```

→ 여러 시나리오 베이스를 병합하고, **순서대로 override/insert** 적용

---

### 방법 2: 조건을 meta로 표현

```yaml
meta:
  country: KR
  user_type: beginner
  car_type: ev
  weather: rain
```

→ 서버에서 meta에 맞는 시나리오를 선택/조합

---

### 📄 `beginner.yaml` – 초보 운전자 추가 안내

```yaml
extends: global
scenario:
  insert_before:
    - name: gear_shift
      new_step:
        name: mirror_check
        prompt_key: beginner_mirror_check
  overrides:
    - name: start_driving
      prompt_key: beginner_start_driving
```

```json
{
  "beginner_mirror_check": "사이드미러와 백미러를 정확히 조정했는지 확인하세요.",
  "beginner_start_driving": "천천히, 부드럽게 출발하세요. 급출발은 위험합니다."
}
```

---

## ✅ 구현 시 고려 사항

| 항목         | 설명                                  |
| ---------- | ----------------------------------- |
| 시나리오 병합 순서 | `extends`에 선언된 순서대로 적용 (뒤의 항목이 덮어씀) |
| step 기준    | `name` 필드로 고유 ID 관리                 |
| insert 위치  | `insert_before`, `insert_after` 사용  |
| prompt 분리  | `prompt_key`로 번역 시스템과 연결됨           |

---

## ✨ 확장 예시

| 시나리오 조합                             | 적용 예            |
| ----------------------------------- | --------------- |
| `global` + `korea`                  | 한국인 운전자         |
| `global` + `usa` + `beginner`       | 미국 초보자          |
| `global` + `korea` + `ev` + `rainy` | 한국, 전기차, 비 오는 날 |

---

## 📌 결론: 시나리오 확장 전략 요약

| 항목            | 전략                                       |
| ------------- | ---------------------------------------- |
| 국가별 규칙        | 시나리오 `extends` 및 `overrides`로 구현         |
| 사용자 유형별 조건    | `beginner.yaml`, `ev.yaml` 등 조합형 시나리오 분리 |
| 언어는 번역만 따로 관리 | prompt\_key 기반 다국어 대응                    |
| 다중 조건 조합      | `meta` 필드 기반 조합 + 병합로직 자동화               |

---

## 🛠️ 도와드릴 수 있는 것

* 시나리오 병합 엔진 (`load_and_merge_yaml()`) 작성
* `insert_before`, `insert_after`, `override` 로직 구현
* 조건 기반 시나리오 조합 처리 (`meta` 기반)
* 다국어 번역 자동 매핑 처리

필요하시면 실제 병합 코드 및 테스트 시나리오 zip으로 만들어 드릴게요.
원하시는 조건 조합으로 예제 만들어볼까요?

---

>>> 지금까지의 내용으로 실제 전체 병합 코드를 보여줘

아래는 `global.yaml`, `korea.yaml`, `beginner.yaml` 세 가지 시나리오를 병합한 결과입니다.

* \*\*`gear_shift`\*\*는 한국용으로 **덮어쓰기** 되었고
* **`seatbelt` 이후**에는 `hpass_check`가,
* **`gear_shift` 이전**에는 `mirror_check`가 **삽입**되었습니다.

전체 병합 결과를 확인해보세요. 이후 이 병합 구조를 LangGraph FSM에 직접 연결할 수 있도록 구성 가능합니다.

원하시면 이 병합 코드도 `.py` 파일로 묶어 zip 제공해드릴게요.

---

>>> 전체 프로젝트 폴더와 파일구조를 보여줘.

아래는 지금까지 구현한 내용(시나리오 상속, 국가별·상황별 병합, 다국어 번역, LangGraph FSM, FastAPI 서버 포함)을 모두 통합한 **전체 프로젝트 폴더 구조**입니다.

---

## 📁 전체 프로젝트 폴더 구조: `driving-agent-ai/`

```
driving-agent-ai/
│
├── README.md
├── requirements.txt
├── Modelfile                         # Ollama용 LLM 정의
│
├── app/                              # LangGraph + FastAPI 서버
│   ├── main.py                       # FastAPI 엔트리포인트
│   ├── langgraph_runner.py          # 병합된 시나리오 + FSM 실행
│   ├── scenario_loader.py           # 시나리오 병합 로직 (상속/덮어쓰기 포함)
│   └── translator.py                # prompt_key -> 언어 번역 처리
│
├── scenarios/                        # YAML 기반 시나리오 정의
│   ├── global.yaml                   # 공통 시나리오
│   ├── korea.yaml                    # 한국 특화 시나리오
│   ├── beginner.yaml                 # 초보 운전자용 시나리오
│   └── ev.yaml                       # 전기차 운전자용 시나리오
│
├── translations/                    # 언어별 텍스트 번역
│   ├── en.json
│   ├── ko.json
│   └── ja.json
│
├── voice/                            # 음성 입출력 연동
│   ├── stt_client.py                 # STT API 연동 (예: Whisper, Google STT)
│   ├── tts_client.py                 # TTS API 연동 (예: Google, Naver, ElevenLabs)
│   └── config.py                     # API 키, 설정 파일
│
├── mobile/                           # 클라이언트 연동
│   ├── android/                      # Android 앱 연동 코드 (Jetpack Compose)
│   └── ios/                          # iOS 앱 연동 코드 (SwiftUI)
│
└── tests/                            # 테스트 코드
    ├── test_scenario_merge.py        # 병합 로직 테스트
    └── test_langgraph_integration.py # FSM 통합 테스트
```

---

## 📌 주요 특징 요약

| 항목                    | 설명                                                            |
| --------------------- | ------------------------------------------------------------- |
| `scenarios/`          | 조건별 YAML 시나리오, 상속 구조 (`extends`, `overrides`, `insert_after`) |
| `translations/`       | 번역 키 → 언어 텍스트 분리                                              |
| `scenario_loader.py`  | 시나리오 병합 로직 (다중 상속 + 지역/상황 반영)                                 |
| `langgraph_runner.py` | 병합된 시나리오 → LangGraph FSM 생성                                   |
| `main.py`             | FastAPI REST API (`/drive`)                                   |
| `voice/`              | STT/TTS 모듈 (음성모드)                                             |
| `mobile/`             | 앱과 연동할 수 있는 REST 기반 구조 제공                                     |

---

## ✨ 확장 계획 시 고려사항

* 시나리오 캐싱 (merged YAML → JSON 저장)
* 시나리오 병합 결과 시각화 도구
* 사용자 세션 기반 상태 지속 저장 (ex: Redis)
* 시나리오별 `test-case.yaml`로 자동 테스트 가능화

---

필요하시면 이 구조로 실제 파일 생성 및 zip 압축도 가능합니다.
zip으로 묶어드릴까요? 아니면 특정 파트부터 완성할까요?

---

>>> 병합된 시나리오 → LangGraph FSM 자동 연결
>>> 이거 진행해줘

현재 환경에는 `LangGraph` 패키지가 설치되어 있지 않아 FSM 자동 생성 코드를 실행할 수 없습니다.
하지만 사용자 로컬 또는 서버 환경에서는 다음 단계를 따라 쉽게 실행 가능합니다.

---

## ✅ 1. 필요한 패키지 설치

```bash
pip install langgraph
```

---

## ✅ 2. 병합된 시나리오 기반 LangGraph FSM 생성 코드

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict

# LangGraph에서 사용할 상태 구조
class AgentState(TypedDict):
    step_index: int
    slots: dict
    prompt: str

# 병합된 시나리오에서 LangGraph 노드 자동 생성 함수
def build_langgraph_from_scenario(merged_scenario: dict):
    steps = merged_scenario["scenario"]["steps"]
    exceptions = merged_scenario["scenario"]["exceptions"]

    graph = StateGraph(AgentState)

    def make_node(step):
        def node_fn(state: AgentState) -> AgentState:
            user_input = state["slots"].get("user_input", "")
            # 예외 탐지
            for rule in exceptions:
                for keyword in rule["trigger"]:
                    if keyword.lower() in user_input.lower():
                        return {**state, "prompt": f"[⚠ 위기상황] {rule['response_key']}"}
            return {
                **state,
                "prompt": f"[{step['name']}] → {step['prompt_key']}",
                "step_index": state.get("step_index", 0) + 1
            }
        return node_fn

    last_node = None
    for step in steps:
        node_name = step["name"]
        graph.add_node(node_name, make_node(step))
        if last_node is None:
            graph.set_entry_point(node_name)
        else:
            graph.add_edge(last_node, node_name)
        last_node = node_name

    graph.add_edge(last_node, END)
    return graph.compile()
```

---

## ✅ 3. 예제 사용 코드

```python
# 병합된 시나리오 로딩 후 FSM 생성
fsm_app = build_langgraph_from_scenario(merged_result)

# 상태 입력 후 실행
initial_state = AgentState(step_index=0, slots={"user_input": "시동 걸었어요"}, prompt="")
result = fsm_app.invoke(initial_state)
print(result["prompt"])
```

---

## 📌 결과

* 병합된 시나리오를 기반으로 LangGraph FSM이 자동 생성
* 단계마다 `step['name']`이 LangGraph 노드가 됨
* `prompt_key`는 번역 또는 텍스트 추출에 사용
* 사용자 입력에 예외 키워드가 포함되면 위기 대응 메시지 출력

---

## 다음 단계 제안

* `prompt_key` → 실제 언어 텍스트 매핑 (다국어 출력)
* LangGraph FSM과 FastAPI 통합
* 사용자 세션별로 FSM 상태 저장 및 이어서 진행

원하시면 이 LangGraph 자동 생성 코드도 `.py` 파일로 정리해서 프로젝트에 포함시켜 드릴게요. 진행할까요?

---

>>> 시나리오가 복잡해지면 yaml 파일로 편집이나 추가가 어려워 지는 상황이 오는데, 이럴땐 어떤 스마트한 방법이 있을까?

맞습니다. 시나리오가 커지고 복잡해질수록 **YAML 파일 직접 편집 방식**은 아래와 같은 문제를 초래하게 됩니다:

---

## ❗️복잡한 YAML 유지의 한계

| 문제점       | 설명                                                |
| --------- | ------------------------------------------------- |
| ❌ 가독성 저하  | 수백 줄 이상의 YAML은 읽기도, 찾기도 어려움                       |
| ❌ 실수 유발   | `indent`, `name`, `insert_after` 등에서 작은 오타도 오류 발생 |
| ❌ 협업 어려움  | 디자이너/기획자와 협업이 힘듦 (비개발자 접근 제한)                     |
| ❌ 중복과 비효율 | 비슷한 단계가 여러 시나리오에 중복 정의됨                           |

---

## ✅ 해결 전략: "스마트한 시나리오 관리 도구"

### 🎯 목표

> 시나리오를 **비개발자도 시각적으로 편집** 가능하고,
> 내부적으로는 YAML/JSON으로 변환되어 병합 가능한 구조를 만들자!

---

## 💡 1. **웹 기반 시나리오 편집 GUI**

### 예시: React + Drag\&Drop Builder

| 기능                            | 설명                                       |
| ----------------------------- | ---------------------------------------- |
| 📋 단계 추가/삭제/순서 변경             | 시각적으로 클릭하여 조작 가능                         |
| 🧩 insert\_before/after       | UI에서 드래그로 위치 지정                          |
| 📝 prompt\_key 직접 입력 or 번역 선택 |                                          |
| 🌍 국가/유형/상황 조건 필터             | 필터 조합으로 시나리오 생성                          |
| 📁 Export                     | JSON or YAML로 저장 (LangGraph 병합 시스템으로 연결) |

---

### 👉 추천 기술 스택

* 프론트엔드: `React`, `Tailwind`, `DND Kit`, `i18n`
* 백엔드 API: FastAPI 기반 파일 저장/변환
* 시나리오 병합 엔진: 기존 Python merge logic 재사용

---

## 💡 2. **Google Sheet 기반 시나리오 설계**

* 각 행이 1개 Step, 각 열이 `name`, `prompt_key`, `condition`, `insert_after`, `override_flag` 등
* 시트에서 관리 → Python으로 CSV 읽고 YAML 자동 생성

| name          | prompt\_key             | insert\_after | condition |
| ------------- | ----------------------- | ------------- | --------- |
| start\_engine | start\_engine           |               | global    |
| mirror\_check | beginner\_mirror\_check | seatbelt      | beginner  |
| hpass\_check  | korea\_hpass            | seatbelt      | korea     |

→ 이 Sheet를 읽어 YAML 파일로 자동 변환하는 **Excel-to-YAML 변환기** 제작 가능

---

## 💡 3. **시나리오 DSL(도메인 특화 언어) 도입**

```yaml
# easy_scenario.dsl.yaml
- when: country == "KR" and user == "beginner"
  do:
    - insert_after: seatbelt
      step:
        name: mirror_check
        prompt_key: beginner_mirror_check
    - override: gear_shift
      prompt_key: gear_shift_korea
```

→ 이를 내부적으로 YAML 구조로 변환하는 파서 생성
→ 복잡한 조건식을 직관적으로 작성 가능

---

## ✅ 정리: 상황에 맞는 선택지

| 방식                  | 대상       | 장점            | 도입 난이도 |
| ------------------- | -------- | ------------- | ------ |
| Web GUI Builder     | 기획자/디자이너 | 시각적이고 실수 없음   | 중\~상   |
| Google Sheet → YAML | 비개발 기획자  | 쉬운 유지보수 + 협업  | 하      |
| DSL 스크립트            | 고급 사용자   | 조건 분기 가독성 극대화 | 중      |

---

## 📦 제가 도와드릴 수 있는 것

* Google Sheet → YAML 변환기 제작 (Python)
* Web 기반 시나리오 편집기 UI 설계/샘플 구현
* DSL 기반 시나리오 정의/변환기 설계

---

어떤 방식이 가장 적합해 보이시나요?
예를 들어 Web GUI부터 시작할까요, 아니면 Excel 기반으로 관리부터 개선해볼까요?

---

```javascript
// ScenarioGuiBuilder.tsx
import { useState, useCallback } from "react";
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  addEdge,
  useNodesState,
  useEdgesState,
  ReactFlowProvider,
  Handle,
  Position,
} from "reactflow";
import "reactflow/dist/style.css";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider } from "@/components/ui/tooltip";

const translationMap = {
  ko: {
    start_engine: "시동을 걸어주세요.",
    seatbelt: "안전벨트를 착용하세요.",
    gear_shift: "기어를 P에서 D로 변경하세요.",
    condition_step_1: "조건 분기 예시입니다.",
    error_step_2: "예외 처리 예시입니다.",
  },
  en: {
    start_engine: "Please start the engine.",
    seatbelt: "Fasten your seatbelt.",
    gear_shift: "Shift the gear from P to D.",
    condition_step_1: "This is a conditional step.",
    error_step_2: "This is an error handler step.",
  },
};

let id = 0;
const getId = () => `step-${id++}`;

function CustomNode({ data }) {
  const lang = "ko";
  const translation = translationMap[lang]?.[data.promptKey] || "";
  const allTranslations = Object.entries(translationMap)
    .map(([lang, dict]) => `${lang}: ${dict[data.promptKey] || "(없음)"}`)
    .join("\n");

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <div
            className={`border rounded p-2 shadow w-60 cursor-pointer ${data.type === "condition" ? "bg-yellow-100" : data.type === "error" ? "bg-red-100" : "bg-white"}`}
          >
            <Handle type="target" position={Position.Top} />
            <div className="text-sm font-bold mb-1">{data.label} ({data.type || "normal"})</div>
            <Input
              className="text-xs mb-1"
              value={data.promptKey || ""}
              onChange={(e) => data.onPromptChange(data.id, e.target.value)}
              placeholder="prompt_key"
            />
            <div className="text-xs italic text-gray-500 min-h-[1.25rem]">
              🌐 {translation || "(번역 없음)"}
            </div>
            <Handle type="source" position={Position.Bottom} />
          </div>
        </TooltipTrigger>
        <TooltipContent side="right">
          <pre className="text-xs whitespace-pre-wrap">{allTranslations}</pre>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}

const nodeTypes = {
  custom: CustomNode,
};

function FlowEditor() {
  const initialNodes = [
    {
      id: getId(),
      type: "custom",
      position: { x: 100, y: 100 },
      data: { label: "start_engine", promptKey: "start_engine", type: "normal", onPromptChange },
    },
  ];

  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);

  const onConnect = useCallback(
    (params) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  const addNode = (type = "normal") => {
    const newId = getId();
    const newNode = {
      id: newId,
      type: "custom",
      position: {
        x: Math.random() * 400 + 100,
        y: Math.random() * 400 + 100,
      },
      data: {
        id: newId,
        label: `${type}_step_${id}`,
        promptKey: `${type}_step_${id}`,
        type,
        onPromptChange,
      },
    };
    setNodes((nds) => [...nds, newNode]);
  };

  const onPromptChange = (id, newPrompt) => {
    setNodes((nds) =>
      nds.map((n) =>
        n.id === id ? { ...n, data: { ...n.data, promptKey: newPrompt } } : n
      )
    );
  };

  const exportFSM = () => {
    const nodeMap = Object.fromEntries(nodes.map((n) => [n.id, n.data.label]));
    const code = `from langgraph.graph import StateGraph, END\n\nclass AgentState(dict):\n    pass\n\ndef make_node(prompt):\n    def node_fn(state):\n        return {**state, \"prompt\": prompt, \"step_index\": state.get(\"step_index\", 0) + 1}\n    return node_fn\n\ngraph = StateGraph(AgentState)\n`;

    const nodeDefs = nodes
      .map(
        (n) => `graph.add_node(\"${n.data.label}\", make_node(\"${n.data.promptKey || n.data.label}\"))`
      )
      .join("\n");

    const edgeDefs = edges
      .map(
        (e) =>
          `graph.add_edge(\"${nodeMap[e.source]}\", \"${nodeMap[e.target]}\")`
      )
      .join("\n");

    const entry = nodes.length > 0 ? `graph.set_entry_point(\"${nodes[0].data.label}\")` : "";
    const compile = "\nfsm_app = graph.compile()";
    alert(`${code}\n${nodeDefs}\n${edgeDefs}\n${entry}${compile}`);
  };

  return (
    <div className="w-full h-[600px]">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        fitView
        nodeTypes={nodeTypes}
      >
        <Background />
        <Controls />
        <MiniMap />
      </ReactFlow>
      <div className="flex gap-2 mt-4 p-4">
        <Button onClick={() => addNode("normal")}>노드 추가</Button>
        <Button onClick={() => addNode("condition")}>조건 분기 노드 추가</Button>
        <Button onClick={() => addNode("error")}>예외 노드 추가</Button>
        <Button onClick={exportFSM}>LangGraph FSM 코드 생성</Button>
      </div>
    </div>
  );
}

export default function ScenarioBuilder() {
  return (
    <div className="p-4 max-w-full">
      <h1 className="text-xl font-bold mb-4">🧠 시나리오 그래프 빌더</h1>
      <ReactFlowProvider>
        <FlowEditor />
      </ReactFlowProvider>
    </div>
  );
}

```

---

>>> 아래 기능을 모두 포함해서 구현해줘
>>> 
>>> 📥 YAML DSL → GUI 자동 로딩
>>> 📤 GUI → YAML DSL 자동 내보내기
>>> 🌍 언어 선택 드롭다운

``` javascript
// ScenarioGuiBuilder.tsx
import { useState, useCallback, useEffect } from "react";
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  addEdge,
  useNodesState,
  useEdgesState,
  ReactFlowProvider,
  Handle,
  Position,
} from "reactflow";
import "reactflow/dist/style.css";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider } from "@/components/ui/tooltip";
import { loadYamlScenario, exportToYaml } from "@/lib/yamlHelper";
import { loadTranslations } from "@/lib/i18nLoader";

const nodeTypes = {
  custom: CustomNode,
};

let id = 0;
const getId = () => `step-${id++}`;

function CustomNode({ data }) {
  const { translations, selectedLang } = data;
  const translation = translations?.[selectedLang]?.[data.promptKey] || "";
  const allTranslations = Object.entries(translations || {})
    .map(([lang, dict]) => `${lang}: ${dict[data.promptKey] || "(없음)"}`)
    .join("\n");

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <div
            className={`border rounded p-2 shadow w-60 cursor-pointer ${data.type === "condition" ? "bg-yellow-100" : data.type === "error" ? "bg-red-100" : "bg-white"}`}
          >
            <Handle type="target" position={Position.Top} />
            <div className="text-sm font-bold mb-1">{data.label} ({data.type || "normal"})</div>
            <Input
              className="text-xs mb-1"
              value={data.promptKey || ""}
              onChange={(e) => data.onPromptChange(data.id, e.target.value)}
              placeholder="prompt_key"
            />
            <div className="text-xs italic text-gray-500 min-h-[1.25rem]">
              🌐 {translation || "(번역 없음)"}
            </div>
            <Handle type="source" position={Position.Bottom} />
          </div>
        </TooltipTrigger>
        <TooltipContent side="right">
          <pre className="text-xs whitespace-pre-wrap">{allTranslations}</pre>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}

function FlowEditor() {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [translations, setTranslations] = useState({});
  const [selectedLang, setSelectedLang] = useState("ko");

  const onConnect = useCallback(
    (params) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  const onPromptChange = (id, newPrompt) => {
    setNodes((nds) =>
      nds.map((n) =>
        n.id === id ? { ...n, data: { ...n.data, promptKey: newPrompt } } : n
      )
    );
  };

  const addNode = (type = "normal") => {
    const newId = getId();
    const newNode = {
      id: newId,
      type: "custom",
      position: {
        x: Math.random() * 400 + 100,
        y: Math.random() * 400 + 100,
      },
      data: {
        id: newId,
        label: `${type}_step_${id}`,
        promptKey: `${type}_step_${id}`,
        type,
        translations,
        selectedLang,
        onPromptChange,
      },
    };
    setNodes((nds) => [...nds, newNode]);
  };

  const exportToYamlDSL = () => {
    const yaml = exportToYaml(nodes, edges);
    console.log(yaml);
    alert("YAML DSL 콘솔에 출력됨");
  };

  const loadYaml = async () => {
    const { nodes: loadedNodes, edges: loadedEdges } = await loadYamlScenario("/example/scenario.yaml", translations, selectedLang, onPromptChange);
    setNodes(loadedNodes);
    setEdges(loadedEdges);
  };

  useEffect(() => {
    loadTranslations(selectedLang).then(setTranslations);
  }, [selectedLang]);

  return (
    <div className="w-full h-[600px]">
      <div className="flex gap-2 mb-2">
        <select value={selectedLang} onChange={(e) => setSelectedLang(e.target.value)} className="border p-1 rounded">
          <option value="ko">한국어</option>
          <option value="en">English</option>
        </select>
        <Button onClick={() => addNode("normal")}>노드 추가</Button>
        <Button onClick={() => addNode("condition")}>조건 분기 노드 추가</Button>
        <Button onClick={() => addNode("error")}>예외 노드 추가</Button>
        <Button onClick={loadYaml}>📥 YAML 불러오기</Button>
        <Button onClick={exportToYamlDSL}>📤 YAML 내보내기</Button>
      </div>

      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        fitView
        nodeTypes={nodeTypes}
      >
        <Background />
        <Controls />
        <MiniMap />
      </ReactFlow>
    </div>
  );
}

export default function ScenarioBuilder() {
  return (
    <div className="p-4 max-w-full">
      <h1 className="text-xl font-bold mb-4">🧠 시나리오 그래프 빌더</h1>
      <ReactFlowProvider>
        <FlowEditor />
      </ReactFlowProvider>
    </div>
  );
}
```

✅ 이제 다음 기능이 포함된 **최종 GUI 빌더 코드**로 업데이트되었습니다:

---

### 🧩 포함된 주요 기능:

| 기능                        | 설명                                            |
| ------------------------- | --------------------------------------------- |
| 📥 YAML DSL → GUI 자동 로딩   | `loadYamlScenario()` 호출 시 YAML 시나리오를 GUI로 시각화 |
| 📤 GUI → YAML DSL 자동 내보내기 | 버튼 클릭 시 현재 GUI 상태를 YAML로 추출                   |
| 🌍 언어 선택 드롭다운             | 언어를 선택하면 해당 언어의 번역이 툴팁 및 노드에 반영됨              |

---

### 📁 추가 연동 구성 제안:

* `/public/example/scenario.yaml`: 예제 시나리오 파일
* `/translations/ko.json`, `/translations/en.json`: 언어별 JSON 번역 파일
* `i18nLoader.ts`, `yamlHelper.ts`: 헬퍼 유틸로 번역 및 YAML 변환 처리

필요하시면 위 파일들도 바로 구성해드릴 수 있습니다. 계속해서 어떤 기능을 추가하거나 배포할지 알려주세요!

---

>>> 위 코드를 로컬에서 돌려보고 싶어. 어떻게 해야하는지 모든 단계를 설명해줘

좋아요! 지금 보고 계신 **React 기반 GUI 시나리오 빌더 코드**를 로컬에서 실행하려면 아래와 같이 단계별로 진행하시면 됩니다.

---

## ✅ 1. 필수 준비 사항

* Node.js (18.x 이상 권장)
* 패키지 매니저: `npm` 또는 `yarn`
* 코드 편집기 (VSCode 등)

---

## 📁 2. 프로젝트 구조 만들기

```bash
mkdir scenario-gui-builder
cd scenario-gui-builder
npm create vite@latest
# ✔ 프로젝트 이름: scenario-gui-builder
# ✔ 프레임워크: React
# ✔ Variant: TypeScript
cd scenario-gui-builder
```

---

## 📦 3. 패키지 설치

```bash
npm install
npm install reactflow
npm install clsx
npm install tailwindcss postcss autoprefixer
npx tailwindcss init -p
```

### `tailwind.config.js` 수정:

```ts
content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
```

### `src/index.css` 수정:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

---

## 🧠 4. 컴포넌트 및 유틸 파일 구성

### `src/components/ScenarioGuiBuilder.tsx` → 복사 붙여넣기

(지금 보고 계신 전체 코드)

### `src/components/ui/` 폴더 생성 후 다음 구성:

* `button.tsx`: Tailwind Button 컴포넌트
* `input.tsx`: Tailwind Input 컴포넌트
* `tooltip.tsx`: Tooltip용 래퍼 컴포넌트

(필요하면 샘플 코드 드릴 수 있습니다)

---

## 🌍 5. 번역 및 YAML 파일 구성

### 폴더 구조:

```
/public/
  ├── translations/
  │     ├── ko.json
  │     └── en.json
  └── example/
        └── scenario.yaml
```

### `ko.json` 예시:

```json
{
  "start_engine": "시동을 걸어주세요.",
  "seatbelt": "안전벨트를 착용하세요."
}
```

### `scenario.yaml` 예시:

```yaml
nodes:
  - id: start_engine
    type: normal
    prompt_key: start_engine
  - id: seatbelt
    type: normal
    prompt_key: seatbelt
edges:
  - from: start_engine
    to: seatbelt
```

---

## ⚙️ 6. 유틸 파일 추가

### `src/lib/i18nLoader.ts`

```ts
export async function loadTranslations(lang: string): Promise<Record<string, string>> {
  const res = await fetch(`/translations/${lang}.json`);
  return await res.json();
}
```

### `src/lib/yamlHelper.ts`

```ts
import YAML from 'yaml';

export function exportToYaml(nodes: any[], edges: any[]) {
  const yaml = YAML.stringify({ nodes, edges });
  return yaml;
}

export async function loadYamlScenario(path: string, translations: any, lang: string, onPromptChange: Function) {
  const res = await fetch(path);
  const text = await res.text();
  const parsed = YAML.parse(text);
  const nodes = (parsed.nodes || []).map((n, idx) => ({
    id: n.id || `node-${idx}`,
    type: "custom",
    position: { x: 100 + idx * 50, y: 100 + idx * 50 },
    data: {
      id: n.id,
      label: n.prompt_key,
      promptKey: n.prompt_key,
      type: n.type || "normal",
      translations,
      selectedLang: lang,
      onPromptChange
    }
  }));
  const edges = parsed.edges || [];
  return { nodes, edges };
}
```

---

## 🚀 7. 실행

```bash
npm run dev
```

브라우저에서: [http://localhost:5173](http://localhost:5173)

---

## 📦 번들로 만들기

```bash
npm run build
```

---

## 📁 원하시면…

* 전체 구조 `.zip` 파일로 패키징
* GitHub 배포용 템플릿 구성
* Vercel / Netlify로 배포

도 도와드릴 수 있어요. 필요하신가요?

---

>>> 윈도우 환경에서 돌려보고 싶어

좋아요! Windows 환경에서 지금 보고 계신 **React 기반 시나리오 GUI 빌더**를 로컬에서 실행하려면 다음 단계를 그대로 따라 하시면 됩니다. (Windows 10 또는 11 기준)

---

## ✅ 1. 필수 설치

### 📦 Node.js 설치

* 공식 웹사이트: [https://nodejs.org](https://nodejs.org)
* LTS 버전 (권장): `v18.x` 이상

👉 설치 후, 아래 명령어로 설치 확인:

```bash
node -v
npm -v
```

---

## 🧱 2. 프로젝트 생성

### 터미널(Powershell, CMD, 혹은 Git Bash) 열기:

```bash
mkdir scenario-gui-builder
cd scenario-gui-builder
npm create vite@latest
```

* 프로젝트 이름: `scenario-gui-builder`
* 프레임워크: `React`
* Variant: `TypeScript`

```bash
cd scenario-gui-builder
npm install
```

---

## 🧩 3. 필요한 패키지 설치

```bash
npm install reactflow
npm install clsx
npm install yaml
npm install tailwindcss postcss autoprefixer
npx tailwindcss init -p
```

---

## 🎨 4. Tailwind 설정

### 📄 `tailwind.config.js` 수정

```js
module.exports = {
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

### 📄 `src/index.css` 수정

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

---

## 📁 5. 디렉토리 구조 생성

```
scenario-gui-builder/
├── public/
│   ├── translations/
│   │   ├── ko.json
│   │   └── en.json
│   └── example/
│       └── scenario.yaml
├── src/
│   ├── components/
│   │   └── ScenarioGuiBuilder.tsx ← ⬅️ 코드 붙여넣기
│   ├── lib/
│   │   ├── i18nLoader.ts
│   │   └── yamlHelper.ts
│   └── main.tsx
```

---

## 🌍 6. 예제 데이터 준비

### ✅ `public/translations/ko.json`

```json
{
  "start_engine": "시동을 걸어주세요.",
  "seatbelt": "안전벨트를 착용하세요.",
  "gear_shift": "기어를 변경하세요."
}
```

### ✅ `public/example/scenario.yaml`

```yaml
nodes:
  - id: start_engine
    type: normal
    prompt_key: start_engine
  - id: seatbelt
    type: normal
    prompt_key: seatbelt
edges:
  - from: start_engine
    to: seatbelt
```

---

## 🧠 7. 유틸 파일 코드

### ✅ `src/lib/i18nLoader.ts`

```ts
export async function loadTranslations(lang: string): Promise<Record<string, string>> {
  const res = await fetch(`/translations/${lang}.json`);
  return await res.json();
}
```

### ✅ `src/lib/yamlHelper.ts`

```ts
import YAML from "yaml";

export function exportToYaml(nodes: any[], edges: any[]) {
  return YAML.stringify({
    nodes: nodes.map(n => ({
      id: n.data.id,
      type: n.data.type,
      prompt_key: n.data.promptKey
    })),
    edges
  });
}

export async function loadYamlScenario(path: string, translations: any, lang: string, onPromptChange: Function) {
  const res = await fetch(path);
  const text = await res.text();
  const parsed = YAML.parse(text);
  const nodes = (parsed.nodes || []).map((n, idx) => ({
    id: n.id || `node-${idx}`,
    type: "custom",
    position: { x: 100 + idx * 80, y: 100 + idx * 50 },
    data: {
      id: n.id,
      label: n.prompt_key,
      promptKey: n.prompt_key,
      type: n.type || "normal",
      translations,
      selectedLang: lang,
      onPromptChange,
    },
  }));
  const edges = parsed.edges || [];
  return { nodes, edges };
}
```

---

## 🚀 8. 실행

```bash
npm run dev
```

* 실행 후 브라우저에서 접속: [http://localhost:5173](http://localhost:5173)

---

## 📦 9. 빌드 (선택)

```bash
npm run build
```

빌드된 결과물은 `/dist` 폴더에 생성됩니다.

---

## ❓ 도움이 필요하신가요?

* `.zip` 형태로 전체 프로젝트 제공 가능
* GitHub에 업로드 가능한 기본 템플릿 제공 가능
* Vercel 또는 Netlify로 배포도 도와드릴 수 있어요

필요하신 항목 알려주세요!
